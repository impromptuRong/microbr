################################################################################
# What's in this wrapper-methods.R file: 
# baseinfo_analysis:  
# ordinate_analysis: 
# supervise_learning: 
# unsupervise_learning: 
# feature_selection: 
# enterotpe_analysis: 
################################################################################
#' @title Abundance and Cont table analysis wrapper
#' @description Basic taxa abundance and alpha diversity analysis. 
#' 
#' @param x A \code{\link{physet-class}} objects.
#' @param formula A formula used for constrain analysis. 
#' @param opts The ploting options generated by \code{\link{phyplotOptions}}. 
#' @param ... other parameters. see Details.
#' @return A large list with the following structure: 
#' 
#' @note
#' support all vegdist and unifrac \cr
#' Mental like Test \cr
#' Intra-group vs. Inter-group distance average \cr
#' PCoA, NMDS, 2d + 3d \cr
#' 
#' @examples
#' data(oral)
#' opts <- phyplotOptions(colorVar = list(sample = "Group", taxa = "Domain"), 
#'                        shapeVar = list(sample = "Periodontitis"), 
#'                        fillVar = list(sample = "Group", taxa = "Domain"))
#' res <- baseinfo_analysis(oral, . ~ Group, opts, rarefy = TRUE, permu = 100)
#' res$tax.boxplot$jitter
#' res$tax.barplot$outlier
#' res$diver.plot$tax.alphaindex$boxplot
#' res$diver.plot$tax.rarefy$group
#' 
#' @rdname baseinfo_analysis
#' @export
#' 
baseinfo_analysis <- function(x, formula, opts, ...) {
  ordlist <- match.call()
  if (!"data" %in% names(ordlist))
    ordlist$data <- quote(sample_data(x))
  if (!"comm" %in% names(ordlist))
    ordlist$comm <- quote(otu_table(x))
  ordlist[[1]] <- NULL
  opts <- phyplotOptions(opts = opts, info = x)
  color <- opts$color
  shape <- opts$shape
  
  res <- list()
  plotDF <- as.matrix(otu_table(x)/seqdep(x))
  if (!is.null(opts$keepOnly$sample))
    plotDF <- plotDF[opts$keepOnly$sample, , drop = FALSE]
  if (!is.null(opts$keepOnly$taxa))
    plotDF <- plotDF[, opts$keepOnly$taxa, drop = FALSE]
  plotDF <- merge(.m2df(plotDF), opts$info$sample, by.x = "Row.names", 
                  by.y = 0, all.x = TRUE, sort = FALSE)
  plotDF <- merge(plotDF, opts$info$taxa, by.x = "Col.names", by.y = 0, 
                  all.x = TRUE, sort = FALSE, suffixes = c(".S",".T"))
  
  ## boxplot without jitter
  pbox_o <- ggplot(plotDF, aes_string(x="labelVar.T", y="x", fill="colorVar.S")) + 
    geom_boxplot(outlier.size = 1.5) + 
    scale_fill_manual(values = color) + theme_bw() + 
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
    labs(y = "Relative Abundance", x = "") + 
    facet_grid( ~ colorVar.T, scales = "free", space = "free", drop = TRUE)
  
  ## boxplot with jitter
  pbox_j <- ggplot(plotDF, aes_string(x="labelVar.T", y="x", fill="colorVar.S")) + 
    geom_boxplot(outlier.colour = "NA") + 
    geom_point(aes_string(color = "colorVar.S"), 
               position = "jitter", size = 1.5, alpha = I(1/2)) + 
    scale_fill_manual(values = color) + theme_bw() + 
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
    labs(y = "Relative Abundance", x = "") + 
    facet_grid( ~ colorVar.T, scales = "free", space = "free", drop = TRUE)

  ## Get facet formula
  plotSB <- doBy::summaryBy(x ~ colorVar.S + labelVar.T, 
                            data = plotDF, FUN = c(mean, sd, length))
  plotSB$x.se <- plotSB$x.sd/sqrt(plotSB$x.length)
  plotSB$lower <- plotSB$x.mean - plotSB$x.se
  plotSB$upper <- plotSB$x.mean + plotSB$x.se
  plotSB <- merge(plotSB, opts$info$taxa, by.x = "labelVar.T", 
                  by.y = "labelVar", all.x = TRUE, sort = FALSE)
  ## Bar Plot with Error bar
  pbar_o <- ggplot(data = plotSB, 
                   aes_string(x="labelVar.T", y="x.mean", fill="colorVar.S")) + 
    geom_bar(stat = "identity", position = "dodge", colour = "black") + 
    geom_errorbar(aes_string(ymin = "lower", ymax = "upper"), width = .25, 
                  position = position_dodge(.9)) + 
    scale_fill_manual(values = color) + theme_bw() + 
    theme(axis.text.x = element_text(angle = 90, hjust = 1)) + 
    labs(y = "Relative Abundance", x = "") + 
    facet_grid( ~ colorVar, scales = "free", space = "free", drop = TRUE)
  pbar_j <- pbar_o
  
  #####   Estimate Richness   #####
  raf <- rarefaction(x, formula, ...)
  
  #####   Summary Result   #####
  res[["tax.boxplot"]] <- list(outlier = pbox_o, jitter = pbox_j)
  res[["tax.barplot"]] <- list(outlier = pbar_o, jitter = pbar_j)
  res[["diver.alpha"]] <- raf
  res[["diver.plot"]] <- plot(raf, opts)
  return(res)
}
################################################################################
#' @title Distance and Ordination analysis wrapper
#' 
#' @param x A \code{\link{physet-class}} objects.
#' @param formula A formula used for constrain analysis. 
#' @param methods A set of method name passed to \code{\link{phydist}}. 
#' @param opts The ploting options generated by \code{\link{phyplotOptions}}. 
#' @param ... other parameters. see Details.
#' @return A large list with the following structure: 
#' 
#' @note
#' support all vegdist and unifrac \cr
#' Mental like Test \cr
#' Intra-group vs. Inter-group distance average \cr
#' PCoA, NMDS, 2d + 3d \cr
#' 
#' @examples
#' data(oral)
#' opts <- phyplotOptions(colorVar = list(sample = "Group", taxa = "Domain"), 
#'                        shapeVar = list(sample = "Periodontitis"), 
#'                        fillVar = list(sample = "Group", taxa = "Domain"))
#' res <- ordinate_analysis(oral, . ~ Group, opts, "unifrac.w.un")
#' res$biplot
#' res$splitplot
#' 
#' @rdname ordinate_analysis
#' @export
#' 
ordinate_analysis <- function(x, formula, opts, methods, ...) {
  ordlist <- match.call()
  if (!"data" %in% names(ordlist))
    ordlist$data <- quote(sample_data(x))
  if (!"comm" %in% names(ordlist))
    ordlist$comm <- quote(otu_table(x))
  ordlist[[1]] <- NULL
  opts <- phyplotOptions(opts = opts, info = x)
  
  res <- list()
  #######   CA, DCA, CCA, PCA, RDA   #######
  CA <- eval(as.call(c(quote(ordinate), apply = "CA", ordlist)))
  res$ordination$CA$ordinate <- CA
  res$ordination$CA$figures <- plot(CA, opts, ...)
  DCA <- eval(as.call(c(quote(ordinate), apply = "DCA", ordlist)))
  res$ordination$DCA$ordinate <- DCA
  res$ordination$DCA$figures <- plot(DCA, opts, ...)
  CCA <- eval(as.call(c(quote(ordinate), apply = "CCA", ordlist)))
  res$ordination$CCA$ordinate <- CCA
  res$ordination$CCA$figures <- plot(CCA, opts, ...)
  PCA <- eval(as.call(c(quote(ordinate), apply = "PCA", ordlist)))
  res$ordination$PCA$ordinate <- PCA
  res$ordination$PCA$figures <- plot(PCA, opts, ...)
  RDA <- eval(as.call(c(quote(ordinate), apply = "RDA", ordlist)))
  res$ordination$RDA$ordinate <- RDA
  res$ordination$RDA$figures <- plot(RDA, opts, ...)
  
  print("ordination done!")
  #######   CAP, PCoA, NMDS   #######
  ordlist$x <- quote(distance)
  for (method in methods) {
    distance <- phydist(x, method = method, ...)
    res$method$dist <- distance
    fx <- formula
    fx[2] <- expression(distance)
    res$method$signif <- vegan::adonis(fx, data = sample_data(x))
    
    #######   2D plot   #######
    CAP <- eval(as.call(c(quote(ordinate), apply = "CAP", ordlist)))
    res$method$CAP$ordinate <- CAP
    res$method$CAP$figures <- plot(CAP, opts, ...)
    PCoA <- eval(as.call(c(quote(ordinate), apply = "PCoA", ordlist)))
    res$method$PCoA$ordinate <- PCoA
    res$method$PCoA$figures <- plot(PCoA, opts, ...)
    NMDS <- eval(as.call(c(quote(ordinate), apply = "NMDS", ordlist)))
    res$method$NMDS$ordinate <- NMDS
    res$method$NMDS$figures <- plot(NMDS, opts, ...)
    
    print("Distance Done!")
    #######   3D plot, seldom used   #######
    if (!is.null(opts$axes.3d)) {
      CAP <- eval(as.call(c(quote(ordinate), apply = "CAP", ordlist, k = 3)))
      res$method$CAP$ordinate3 <- CAP
      res$method$CAP$figures3 <- plot(CAP, opts, ...)
      PCoA <- eval(as.call(c(quote(ordinate), apply = "PCoA", ordlist)))
      res$method$PCoA$ordinate3 <- PCoA
      res$method$PCoA$figures3 <- plot(PCoA, opts, ...)
      NMDS <- eval(as.call(c(quote(ordinate), apply = "NMDS", ordlist)))
      res$method$NMDS$ordinate3 <- NMDS
      res$method$NMDS$figures3 <- plot(NMDS, opts, ...)
    }
    
    #######   Grouping Test and Plotting   #######
    rhs <- all.vars(formula[-2])
    if (length(rhs) != 0) {
      group <- eval(ordlist$data)[[rhs[1]]]
      
      ## Beta diversity against classification Test
      com <- combn(unique(group), 2)
      betaGT <- matrix(0, ncol(com) + 1, 3, dimnames = 
                         list(c("all", paste(com[1,], com[2,], sep=" vs ")), 
                              c("Anosim","MRPP","perMANOVA")))
      
      betaGT[1, ] <- c(vegan::anosim(distance, group)$signif, 
                       vegan::mrpp(distance, group)$Pvalue, 
                       vegan::adonis(distance ~ group)$aov.tab$"Pr(>F)"[1])
      for (i in 1:ncol(com)) {
        sub_id <- (group == com[1, i]) | (group == com[2, i])
        sub_dm <- as.dist(as.matrix(distance)[sub_id, sub_id])
        sub_group <- group[sub_id]
        betaGT[i+1,] <- c(vegan::anosim(sub_dm, sub_group)$signif, 
                          vegan::mrpp(sub_dm, sub_group)$Pvalue, 
                          vegan::adonis(sub_dm~sub_group)$aov.tab$"Pr(>F)"[1])
      }
      res$method$grouping$betatest <- betaGT
      
      print("betaGT done!")
      #######   Beta diversity Intra/Inter-Group Test   #######
      com <- cbind(rbind(unique(group), unique(group)), com)
      pdlist <- lapply(1:ncol(com), function(i) {
        as.vector(as.matrix(distance)[group == com[1,i], group == com[2,i]])})
      cmp <- rep(paste(com[1,], com[2,], sep = " vs "), 
                 sapply(pdlist, function(x){length(x)}))
      plotDF <- data.frame(cmp = cmp, pdist = unlist(pdlist))
      plotDF <- plotDF[plotDF$pdist != 0, ]
      plotSB <- doBy::summaryBy(pdist ~ cmp, plotDF, FUN = function(p, ...) {
        c(mean=mean(p, ...), sd=sd(p, ...), len=length(p))}, na.rm = TRUE)
      plotSB$pdist.se <- plotSB$pdist.sd/sqrt(plotSB$pdist.len)
      plotSB$lower <- plotSB$pdist.mean - plotSB$pdist.se
      plotSB$upper <- plotSB$pdist.mean + plotSB$pdist.se
      pwsignif <- try(pairwise.t.test(plotDF$pdist, plotDF$cmp, pool.sd = FALSE, 
                                      p.adjust.method = "none")$p.value)
      res$method$grouping$pwinfo <- plotSB
      res$method$grouping$pwtest <- pwsignif
      
      print("Intra/Inter test done!")
      #######   boxplot for Intra/Inter-Group Test   #######
      pbox <- ggplot(plotDF, aes_string(x = "cmp", y = "pdist")) + 
        geom_boxplot() + theme_bw() + scale_y_continuous(method)
      res$method$grouping$pwboxv <- pbox + coord_flip() + 
        theme(axis.text.x=element_text(size=6), axis.title.x=element_blank(), 
              axis.text.y=element_text(size=8), axis.title.y=element_blank(), 
              # panel.grid.minor=element_blank(), 
              # panel.grid.major=element_line(colour='grey', linetype='dashed'), 
              legend.key=element_blank())
      res$method$grouping$pwboxh <- pbox + 
        theme(axis.text.x=element_text(size=8, angle=90), 
              axis.title.x=element_blank(),
              axis.text.y=element_text(size=6), axis.title.y=element_blank(), 
              # panel.grid.major=element_blank(), 
              # panel.grid.minor=element_line(colour='grey', linetype='dashed'), 
              legend.key=element_blank())
      
      print("box-plot done!")
      #######   barplot for Intra/Inter-Group Test  #######
      pbar <- ggplot(plotSB, aes_string(x="cmp", y="pdist.mean")) + theme_bw() + 
        geom_bar(stat = "identity", colour = "black", fill = "white") + 
        geom_errorbar(aes_string(ymin = "lower", ymax = "upper"), 
                      width = .25, position = position_dodge(.9))
      res$method$grouping$pwbarv <- pbar + coord_flip() + 
        theme(axis.text.x=element_text(size=6), axis.title.x=element_blank(), 
              axis.text.y=element_text(size=8), axis.title.y=element_blank(), 
              # panel.grid.major=element_blank(), 
              # panel.grid.minor=element_line(colour='grey', linetype='dashed'), 
              legend.key=element_blank())
      res$method$grouping$pwbarh <- pbar + 
        theme(axis.text.x=element_text(size=8, angle=90), 
              axis.title.x=element_blank(), 
              axis.text.y=element_text(size=6), axis.title.y=element_blank(), 
              # panel.grid.major=element_blank(), 
              # panel.grid.minor=element_line(colour='grey', linetype='dashed'), 
              legend.key=element_blank())
      print("bar-plot done!")
    }
  }
  return(res)
}
################################################################################
#' @title Enterotype analysis for objects 
#' 
#' @description This is the enterotype analysis wrapper based on the code in 
#' enterotype official website. 
#' 
#' @param x A matrix, or \code{\link{physet-class}} objects. 
#' @param method The distance method used for pam clustering. 
#' @param ... other parameters passed to clustering \code{\link[cluster]{pam}} 
#' and distance method \code{\link{phydist}}. 
#' @return A large list with the following structure: 
#' 
#' @references enterotype official website
#' @examples
#' data(oral)
#' res <- enterotype_analysis(oral)
#' plot(res$nclusters, type = "h", xlab = "k clusters", ylab = "CH index")
#' res$data.cluster
#' res$distance
#' @rdname enterotype_analysis
#' @export
#' 
enterotype_analysis <- function(x, method = "JSD", ...){
  arglist <- c(x = quote(x), method = method, list(...))
  ##  Calculate Dissimilarity, default is JSD
  dm <- phydist(x, method = method, ...)
  arglist$x <- quote(dm)
  del_names <- setdiff(names(arglist), names(formals(cluster::pam)))
  for (i in del_names) arglist[[i]] <- NULL
  if(inherits(x, "physet"))
    x <- as.matrix(otu_table(x))/seqdep(x)

  ##  PAM clustering with Optimal number of clusters
  Nk <- c(NA, sapply(2:20, function(k) {
    arglist$k <- k
    dc <- eval(as.call(c(quote(cluster::pam), arglist)))
    clusterSim::index.G1(x, dc$clustering, d = dm, centrotypes = "medoids")}))
  arglist$k <- which.max(Nk)
  data.cluster <- eval(as.call(c(quote(cluster::pam), arglist)))
  result <- list(nclusters = Nk, cluster = data.cluster, distance = dm, 
                 silhouette = mean(cluster::silhouette(data.cluster, dm)[,3]))
  return(result)
  
  #####  Graphical interpretation  #####
  ## Between-class analysis
  ## Remove noise
  # data.denoized <- noise.removal(data, percent=0.01)  
  # plot(nclusters, type="h", xlab="k clusters", ylab="CH index")

  ## PCA plot
  # obs.pca <- ade4::dudi.pca(data.frame(t(data)), scannf=F, nf=10)
  # obs.bet <- ade4::bca(obs.pca, fac=as.factor(data.cluster), scannf=F, nf=k-1)
  # ade4::s.class(obs.bet$ls, fac=as.factor(data.cluster), grid=F)
  
  ## PCoA plot
  # obs.pcoa <- ade4::dudi.pco(dm, scannf=F, nf=3)
  # ade4::s.class(obs.pcoa$li, fac=as.factor(data.cluster), grid=F)
}
################################################################################
#' @title Supervised Learning Feature Selection
#' @description This is the wrapper for several feature selection methods. 
#' 
#' @param data A matrix, or \code{\link{physet-class}} objects. 
#' @param group The grouping variable or a factor. 
#' @param methods The list of selection methods. 
#' @param ... other parameters passed to feature selection methods. Probably a 
#' kernel function with \code{kernel = "linear"}
#' @return A large list with the following structure: 
#' 
#' @details
#' Statistical Test: T-test, Fisher exact test, 
#' Np T-test, Multi-group comparison \cr
#' Random Forest Selection: Standard entropy method, Boruta selection \cr
#' ENET Selection: ENET Logistic Regression, DrSVM, HHSVM \cr
#' SVM-RFE: 2-group, multi-group \cr
#' Indicator Species: labdsv \cr
#' 
#' @rdname feature_selection
#' @export
#' 
feature_selection <- function(data, group, methods=c("StaTest", "RF", "ENet", "ISA", "SVMRFE"), ...){
  if (inherits(data, "physet")) {
    data <- as.matrix(otu_table(data))
    if (is.character(group))
      group <- factor(sample_data(data)[, group])
  }
  feature <- sort(colnames(data))
  data <- data[, feature]
  df <- data.frame(group = group, row.names = rownames(data))
  result <- list()
  summary <- list()
  
  methods <- c("StaTest", "RF", "ENet", "ISA", "SVMRFE") %in% methods
  if(!sum(methods)){
    warning("Input methods is not correct! Only show Univariate Test!")
    method = c(1,0,0,0,0)
  }
  
  ########################################################
  ################  Basic test selection  ################
  if(method[1]){
    print("#### 1. Basic test selection ####")
    print("     1.1 Two-Group Comparison")
    parattest <- phyTtest(data, . ~ group, data = df, p.adj="none", paired=FALSE, alternative="two.sided")
    parachitest <- phyCtest(data, . ~ group, data = df, paired=FALSE, alternative="two.sided")
    result[["BTest.pvalue"]] <- data.frame(parattest$Ttest$none, parattest$Wilcox$none, parachitest$chitest)
    colnames(result[["BTest.pvalue"]]) <- c("Ttest", "Wilcox", "FisherExact")
    result[["BTest.comb_info"]] <- cbind(parattest$comb_info, FisherExact=colnames(data), parachitest$comb_info)
    # write.csv(result[["BTest.comb_info"]], paste(name, ".fs.Test.pairwise.csv", sep=""))
    print("#################################")
    summary[["BTest"]] <- result[["BTest.pvalue"]]<=0.05
    
    if(length(levels(group))>2){
      print("#################################")
      print("     1.2 Multi-Group Comparison")
      MGC <- phyMtest(data, . ~ group, data = df)
      result[["MTest"]] <- MGC
      # write.csv(result[["MTest"]], paste(name, ".fs.Test.group.csv", sep=""))
      print("#################################")
      # summary[["MTest"]] <- result[["BTest.pvalue"]]<=0.05
    }
  }
  
  ########################################################
  ##############   RandomForest Selection   ##############
  if(method[2]){
    print("##  2. RandomForest selection  ##")
    #######      Standard Method       #######
    print("    2.1 Standard Method")
    set.seed(326)
    data.cforest <- party::cforest(group ~ ., data=data.frame(group=group, data), controls=party::cforest_unbiased(ntree=1000, mtry=3))
    if(nlevels(group)==2){
      data.cforest.varimp <- party::varimpAUC(data.cforest, conditional=TRUE)
    } else{
      data.cforest.varimp <- party::varimp(data.cforest, conditional=TRUE)
    }
    criteria <- abs(min(data.cforest.varimp))
    plotdata <- data.frame(Importance=data.cforest.varimp, Taxa=factor(reorder(names(data.cforest.varimp), data.cforest.varimp)))
    # write.csv(plotdata, paste(name, ".fs.RF.coef.csv",sep=""))
    result[["RF.coef"]] <- matrix(plotdata$Importance,,1,dimnames=list(rownames(plotdata),"RF.coef"))
    
    # rf <- randomForest(data, group, ntree=1000)
    # result[["RF"]] <- importance(rf)
    
    plotdata <- plotdata[order(plotdata$Importance,decreasing=TRUE),]
    plotscale <- min(nrow(plotdata), max(sum(plotdata$Importance>criteria), 50))
    result[["RF.varImp"]] <- ggplot(plotdata, aes_string(x="Importance", y="Taxa")) + geom_point(color="blue",size=1.5) + geom_vline(aes(xintercept=0),colour="blue") + 
      geom_vline(aes_string(xintercept=criteria),colour="red",linetype="longdash") + geom_vline(aes_string(xintercept=-criteria),colour="red",linetype="longdash") + 
      scale_y_discrete(limits=plotdata$Taxa[plotscale:1]) + theme_bw()
    
    # png(file=paste(name,".fs.RF.tune.png",sep=""), width=2000, height=plotscale*50+100, res=300)
    # print(result[["RF.varImp"]])
    # dev.off()
    print("#################################")
    summary[["RF.coef"]] <- result[["RF.coef"]]>=abs(min(result[["RF.coef"]]))
    
    #######       Boruta Method        #######
    print("    2.2 Boruta Method")
    boruta <- Boruta::Boruta(group~., data=data.frame(group=group, data), doTrace=2, maxRuns=12, ntree=500) #  Default maxRuns=4
    result[["RF.Boruta"]] <- data.frame(Boruta=boruta$finalDecision)
    # write.csv(result[["RF.Boruta"]], paste(name, ".fs.RF.Boruta.csv",sep=""))
    # borutaplot(boruta, paste(name, ".fs.RF.Boruta.png",sep=""))
    # tmp <- Boruta::TentativeRoughFix(boruta)
    print("#################################")
    summary[["RF.Boruta"]] <- result[["RF.Boruta"]]=="Confirmed"
  }
  
  ########################################################
  #############    ENET LogesicRegression    #############
  ################      HHSVM/DrSVM      #################
  if(method[3]){
    print("###  3. ENET Based selection  ###")
    #######   ENET LogesicRegression   #######      
    print("     3.1 ENET LogesticRegression")
    alpha <- seq(0,1,0.1)
    family <- ifelse(nlevels(group)>2, "multinomial", "binomial")
    measure <- ifelse(nlevels(group)==2&&length(group)>=100, "auc", "class")
    cv.enet <- lapply(alpha, function(x){glmnet::cv.glmnet(data.matrix(data), group, alpha=x, standardize=FALSE, family=family, type.measure=measure)})
    result[["cv.enet.par"]] <- rbind(alpha, sapply(cv.enet, function(x){c(min(x$cvm),x$lambda.min,x$lambda.1se)}))
    rownames(result[["cv.enet.par"]]) <- c("alpha", cv.enet[[1]]$name, "lambda.1se", "lambda.min")
    
    if(nlevels(group)>2){
      result[["cv.enet.coef.1se"]] <- data.matrix(do.call("cBind", lapply(cv.enet, function(x){do.call("cBind", coef(x,s="lambda.1se"))})))
      result[["cv.enet.coef.min"]] <- data.matrix(do.call("cBind", lapply(cv.enet, function(x){do.call("cBind", coef(x,s="lambda.min"))})))
    } else{
      cv.coef <- data.matrix(do.call("cBind", lapply(cv.enet, function(x){coef(x,s="lambda.1se")})))
      result[["cv.enet.coef.1se"]] <- cbind(cv.coef,-cv.coef)[,c(t(matrix(1:(length(alpha)*2),,2)))]
      cv.coef <- data.matrix(do.call("cBind", lapply(cv.enet, function(x){coef(x,s="lambda.min")})))
      result[["cv.enet.coef.min"]] <- cbind(cv.coef,-cv.coef)[,c(t(matrix(1:(length(alpha)*2),,2)))]
    }
    cname <- t(expand.grid(levels(group), alpha))
    cname <- paste(cname[1,],cname[2,],sep="_")
    colnames(result[["cv.enet.coef.1se"]]) <- colnames(result[["cv.enet.coef.min"]]) <- cname
    
    # write.csv(result[["cv.enet.coef.1se"]], paste(name,".fs.ENet.coef.1se.csv",sep=""))
    # write.csv(result[["cv.enet.coef.min"]], paste(name,".fs.ENet.coef.min.csv",sep=""))
    # write.csv(result[["cv.enet.par"]], paste(name,".fs.ENet.par.csv",sep=""))
    
    coef.min <- data.frame(result[["cv.enet.coef.min"]][-1,]!=0)
    colnames(coef.min) <- cname
    tmp <- reshape(coef.min, direction="long", varying=cname, sep="_")
    tmp$coef <- rowSums(tmp[,-c(1,ncol(tmp))])>0
    coef.min <- reshape(tmp[,c("time","id","coef")], direction="wide", new.row.names=rownames(coef.min))
    coef.1se <- data.frame(result[["cv.enet.coef.1se"]][-1,]!=0)
    colnames(coef.1se) <- cname
    tmp <- reshape(coef.1se, direction="long", varying=cname, sep="_")
    tmp$coef <- rowSums(tmp[,-c(1,ncol(tmp))])>0
    coef.1se <- reshape(tmp[,c("time","id","coef")], direction="wide", new.row.names=rownames(coef.1se))
    summary[["cv.enet.coef"]] <- cbind(coef.min[,-1], coef.1se[,-1])
    cname <- t(expand.grid(alpha, c("enet.min","enet.1se")))
    cname <- paste(cname[2,],cname[1,],sep="_")
    colnames(summary[["cv.enet.coef"]]) <- cname
    print("#################################")
    
    if(nlevels(group)==2){
      print("     3.2 ENET SVM")
      #######      HHSVM      #######
      lambda2 <- c(seq(0,1,0.2), seq(2,10,2))
      cv.hhsvm <- lapply(lambda2, function(x){gcdnet::cv.gcdnet(data.matrix(data), group, nfolds=10, pred.loss="misclass", method="hhsvm", standardize=FALSE, lambda2=x)})
      index <- which.min(sapply(cv.hhsvm, function(x){min(x$cvm)}))
      #######   SCAD+L2 SVM   #######
      cv.drHSVM <- try(penalizedSVM::svm.fs(data.matrix(data), y=as.numeric(group)*2-3, fs.method="scad+L2", cross.outer=0, inner.val.method="gacv", show="none", cross.inner=10, verbose=FALSE), TRUE)
      while(class(cv.drHSVM)=="try-error"){
        cv.drHSVM <- try(penalizedSVM::svm.fs(data.matrix(data[,sample(colnames(data))]), y=as.numeric(group)*2-3, fs.method="scad+L2", cross.outer=0, inner.val.method="gacv", show="none", cross.inner=10, verbose=FALSE), TRUE)
      }
      cv.coef <- c(data.matrix(coef(cv.hhsvm[[index]],s="lambda.min")), cv.drHSVM$model$b, cv.drHSVM$model$w[colnames(data)])
      cv.coef[is.na(cv.coef)] <- 0
      result[["cv.DrSVM.coef"]] <- matrix(cv.coef, ncol=2, dimnames=list(c("(Intercept)",colnames(data)),c("hhsvm","drHSVM")))
      result[["cv.DrSVM.par"]] <- matrix(c(min(cv.hhsvm[[index]]$cvm), cv.hhsvm[[index]]$lambda.min, lambda2[index], 
                                           sum(cv.drHSVM$classes!=as.numeric(group)*2-3)/length(group), cv.drHSVM$lambda1, cv.drHSVM$lambda2), 
                                         nrow=3, ncol=2, dimnames=list(c("Misclassification Error","lambda1","lambda2"),c("hhsvm","drHSVM")))
      # write.csv(result[["cv.DrSVM.coef"]], paste(name,".fs.DrSVM.coef.csv",sep=""))
      # write.csv(result[["cv.DrSVM.par"]], paste(name,".fs.DrSVM.par.csv",sep=""))
      print("#################################")
      summary[["cv.DrSVM.coef"]] <- result[["cv.DrSVM.coef"]][-1,]!=0
    }
  }
  
  ########################################################
  ###########    Indicator Species Analysis    ###########
  if(method[4]){
    print("####   4. IndicatorSpecies   ####")
    isa <- labdsv::indval(data, group, numitr=1000)
    # summary(isa, p=0.05, digits=2, show=p)
    result[["ISA"]] <- cbind(isa$indval, pval=isa$pval)
    # write.csv(result[["ISA"]], paste(name, ".fs.ISA.csv", sep=""))
    print("#################################")
    summary[["ISA"]] <- matrix(result[["ISA"]]$pval<=0.05, ncol(data), 1, dimnames=list(colnames(data),"ISA"))
  }
  
  ########################################################
  ################    SVMRFE selection    ################
  if(method[5]){
    print("####   5. SVMRFE Selection   ####")
    if(nlevels(group)==2){
      cv.svmrfe <- pathClass::crossval(data, group, theta.fit=pathClass::fit.rfe, folds=10, repeats=10, scale="scale", stepsize=0.1, parallel=TRUE, DEBUG=FALSE)
      cv.choose <- pathClass::extractFeatures(cv.svmrfe, toFile=FALSE)[colnames(data),]
      cv.choose[is.na(cv.choose)] <- 0
      result[["svmrfe"]] <- matrix(cv.choose, ncol(data), 1, dimnames=list(colnames(data),"svmrfe"))
      # write.csv(result[["svmrfe"]], paste(name,".fs.SVMRFE.linear.csv",sep=""))
      
      # cv.auc <- data.frame(cv.svmrfe$auc)
      # plotdata <- reshape(cv.auc, direction="long", varying=colnames(cv.auc), v.names="AUC", timevar="Repeat", times=colnames(cv.auc), idvar="Fold", ids=rownames(cv.auc))
      # plotdata$Repeat <- factor(reorder(plotdata$Repeat, 1:nrow(plotdata)))
      # plotdata$Fold <- factor(reorder(plotdata$Fold, 1:nrow(plotdata)))
      # ggplot(plotdata, aes(x=Repeat, y=AUC)) + geom_boxplot() + labs(y="AUC", x="") + scale_y_continuous(limits=c(0,1)) + theme_bw() + theme(axis.text.x=element_text(angle=90, hjust=1))
      
      # pred <- prediction(cv.svmrfe$cv, matrix(as.numeric(group)*2-3, nrow(data), ncol(cv.svmrfe$cv)))
      # perf <- performance(pred, measure="tpr", x.measure="fpr")
      # auc <- unlist(performance(pred, "auc")@y.values)
      # a <- data.frame(fpr=unlist(perf@x.values), tpr=unlist(perf@y.values), rep=rep(colnames(cv.svmrfe$cv), each=length()))
      # plot(perf, avg="horizontal", spread.estimate="boxplot", main=paste("mean AUC = ", round(mean(auc),digits=4), sep=""))
      print("#################################")
      summary[["svmrfe"]] <- result[["svmrfe"]]>=50
    }
    
    # ftable <- para_svmrfe(data, group, ID, kernel="linear")
    # result5 <- ftable
    # write.csv(ftable,paste(name, ".fs.svmrfe.",kernel,".csv",sep=""))
  }
  
  ########################################################
  #############    Result Summary/Combine    #############
  result$summary <- summary
  return(result)
}


